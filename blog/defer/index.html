<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="generator" content="Hugo 0.16-DEV" />

  <title>defer &middot; Jesper Stefansson</title>

  
  <link rel="stylesheet" href="/css/blackburn.css">
  <link rel="stylesheet" href="/css/main.css">

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  
  <link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

  
  

  

  <link rel="shortcut icon" href="https://grouse.github.ioimg/favicon.ico" type="image/x-icon" />
</head>




<body>
<div id="layout">

  <button type="button" id="menu_btn" class="hidden-print">
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
	<span class="icon-bar"></span>
</button>

<div id="menu" class="side-menu hidden-print">
	
	<a class="side-menu-heading brand" href="/">Jesper Stefansson</a>
	

	<ul class="side-menu-list">
		
		<li class="side-menu-item">
			<a class="side-menu-link" href="/"><i class='fa fa-home fa-fw'></i>Home</a>
		</li>
		
		<li class="side-menu-item">
			<a class="side-menu-link" href="/resume/"><i class='fa fa-graduation-cap fa-fw'></i>Resume</a>
		</li>
		
		<li class="side-menu-item">
			<a class="side-menu-link" href="/blog"><i class='fa fa-file-text fa-fw'></i>Blog</a>
		</li>
		
		<li class="side-menu-item">
			<a class="side-menu-link" href="/links"><i class='fa fa-link fa-fw'></i>Links</a>
		</li>
		
	</ul>

	<ul class="side-menu-list social">

	

	

	
	<li class="side-menu-item">
		<a class="side-menu-link" href="https://twitter.com/grousejst" target="_blank"><i class="fa fa-twitter-square fa-fw"></i>Twitter</a>
	</li>
	

	

	

	

	

	

	

	

	

	

	

	

	

	

	

	
	<li class="side-menu-item">
		<a class="side-menu-link" href="https://linkedin.com/in/jesperstefansson" target="_blank"><i class="fa fa-linkedin-square fa-fw"></i>LinkedIn</a>
	</li>
	

	

	

	

	

	

	
	<li class="side-menu-item">
		<a class="side-menu-link" href="https://github.com/grouse" target="_blank"><i class="fa fa-github-square fa-fw"></i>GitHub</a>
	</li>
	

	

	

	

	

	

	

	

	

	

	

	
</ul>


	<div>
  <div class="small-print">
    <small>&copy; 2016-2018 Jesper Stefansson</small>
  </div>
</div>

</div>


  <div id="main">


<div class="header">
	<h1>defer</h1>
	<h2></h2>
</div>
<div class="content">
	<div class="post-meta clearfix">
	<div class="date">
		<i class="fa fa-calendar fa-fw"></i>
		<time>2017-04-14, 21:39</time>
	</div>

	

	
	
	
	<div class="tags">
		<i class="fa fa-tags fa-fw"></i>
		
		<a class="post-taxonomy-tag" href="https://grouse.github.io/tags/tutorial">tutorial</a>
		&nbsp;&#47;
		
		<a class="post-taxonomy-tag" href="https://grouse.github.io/tags/c">C</a>
		&nbsp;&#47;
		
		<a class="post-taxonomy-tag" href="https://grouse.github.io/tags/c">C&#43;&#43;</a>
		
		
	</div>
	
	
</div>


	<p>I&rsquo;m not a big fan of the destructors in C++. Don&rsquo;t get me wrong, they can
certainly be useful. I just think they solve a problem in a way that could&rsquo;ve
been implemented in a much more powerful way, without the implicit changes in
behaviour or performance characteristics that adding a destructor comes with.
I&rsquo;m also not at all a fan of non-trivial code hidden away in destructors that I
wasn&rsquo;t expecting, but that&rsquo;s primarily a programmer error.</p>

<p>Enough teasing, here&rsquo;s the code:</p>
template <typename F>
struct Defer {
	Defer(F f) : f(f) {}
	~Defer() { f(); }
	F f;
};

template <typename F>
Defer<F> defer_create(F f) {
	return Defer<F>(f);
};

#define defer__(line) defer_ ## line
#define defer_(line) defer__(line)

struct DeferDummy {};
template<typename F>
Defer<F> operator+ (DeferDummy, F&& f)
{
	return defer_create<F>(std::forward<F>(f));
}

#define defer auto defer_(__LINE__) = DeferDummy() + [&]()

<p>Full credit of this snippet goes to the folks over at <a href="https://handmade.network">https://handmade.network</a>
where this is copied from, with a small change to the naming of the expansion
macros to not clash with glibc.</p>

<div class="note">
	<span class="title">Note:</span>
	<span class="body"><p>Don&rsquo;t prepend anything with double underscore, you&rsquo;re probably gonna clash with
something, somewhere as it&rsquo;s reserved by the compilers in C and C++.</p>
</span>
</div>


<p>In short, the way this works is that you pass a lambda expression to the
constructor for the <code>Defer</code> struct, that it calls during its destructor. The
<code>DeferDummy</code> struct exists so that we can default-construct an object and pass in
the lambda using <code>operator+</code>, this is entirely done in order to keep the defer
macro usage neat and simple.</p>

<p>I&rsquo;ve seen this sort of thing mentioned in a few places, and it&rsquo;s certainly not a
concept invented by C++ macro magicians. It&rsquo;s a first class feature in Go,
Swift, and probably a bunch of other languages. Personally, I was first
introduced to it during one of Jonathan Blow&rsquo;s JAI compiler streams. It&rsquo;s
just recently that I decided to actually incorporate it into my own projects and
see how I actually like it in practice.</p>

<p>It turns out, I like it. I like it a lot. But first, some usage code to figure
out what that macro magic actually allows us to do.</p>
void foo()
{
	defer { printf("world 1!\n"); };
	defer { printf("hello, "); };

	defer {
		printf("hello, ");
		printf("world 2!\n");
	};
}

// outputs:
//   hello world 2!
//   hello world 1!

<p>Referring back to the macro magic, the first statement expands into</p>
auto defer_(__LINE__) = DeferDummy() + [&](){ printf("world 1!\n"); };

<p>In other words, the defer macro starts a lambda expression declaration but
doesn&rsquo;t properly open or close it, we do that ourselves with the <code>{};</code> The <code>;</code>
after the curly braces might look weird at first glance, and would indeed be the
first thing I would want removed in a proper first class version of defer, but
it&rsquo;s required as long as we&rsquo;re forced to hack the feature in using destructors
and lambda expressions.</p>

<p>Because <code>defer</code> is implemented using destructors of <code>Defer</code> objects, the
destructors are called in opposite order of declaration, like unwinding a stack.
This turns out to not only make a lot of sense, but be exactly what we want, as
we want any defer statements close to the beginning of a scope to be called
later than the ones near the end, in order to get proper order of execution in
the cases where the latter defer depends on state cleaned up by the former defer.</p>

<p>There&rsquo;s a few things this allows us to do. The most obvious one is to add a
defer statement freeing a resource or closing a file handle just after we&rsquo;ve
opened it, making it much more obvious that this is taken care of. This is
particularly useful if you like to do early returns, while also avoiding use of
<code>goto</code> to jump to clean-up code. Of course, all of this is one of the primary
reasons for a destructor, but defer is much more versatile as you can trivially
customise which statements are executed or whether it depends on some state in
the function, without having to change or implement a destructor for a struct
which would incur those changes everywhere the struct is already used,
potentially changing performance characteristics or behaviour dependence.</p>

<p>Defer is one of the only things I really want added to the C++ specification as
a first class citizen, but I&rsquo;ve all but given up on the C++ committee actually
adding something useful to the language, so this macro magic solution will keep
me happy for now.</p>


	
	<div class="post-navigation clearfix">
		
		<span class="prev">
			<a href="https://grouse.github.io/blog/live-code-editing/">
				<i class="fa fa-chevron-left"></i>
				live code editing
			</a>
		</span>
		

		
	</div>
	
</div>

		</div>
	</div>

	<script src="/js/ui.js"></script>
	</body>
</html>

